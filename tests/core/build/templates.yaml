templates:
  condition:
    vars:
      RUNNING: 0
      SUCCESS: 1
      FAILURE: 2

    args:
      optional:
        S: default
        F: default

    nodes:
      $name:
        type: skipper
        children: [~SR, ~FR]
        view:
          S: $S
          F: $F

      ~SR:
        type: condition
        expression: $S
        true_state: SUCCESS
        false_state: RUNNING

      ~FR:
        type: condition
        expression: $F
        true_state: FAILURE
        false_state: RUNNING

    children: []

  latch:
    args:
      required: [child]

    nodes:
      $name:
        type: skipper
        children: [~mask, $child]

      ~mask:
        parent: $name
        type: t/condition
        S: __STATE__$child == SUCCESS
        F: __STATE__$child == FAILURE

    children: [$child]



  control_latches_simple:
    args:
      required: [children, control_type]
      construct:
        _children_latched:
          from: children
          V: $V_latch
      view_exclude: [children]

    nodes:
      $name:
        type: $control_type
        children: $_children_latched

    unpack:
      children:
        nodes:
          $V_latch:
            type: t/latch
            child: $V

    children: $children

  seq_latches_simple:
    args:
      required: [children]

    nodes:
      $name:
        type: t/control_latches_simple
        children: $children
        control_type: sequence

    children: $children

  control_latches:
    args:
      required: [children, control_type]
      optional:
        reset_var: ~reset
      construct:
        _reset_children:
          from: children
          V: $V_reset_action

    vars:
      $reset_var: True

    nodes:
      $name:
        type: sequence
        children: [~check_if_reset, ~seq_w_latches]
        view:
          reset: $reset_var

      ~check_if_reset:
        type: fallback
        children: [~if_reset, ~reset_children_and_set_var_back]

      ~if_reset:
        type: t/condition
        F: $reset_var == True
        S: $reset_var != True

      ~reset_children_and_set_var_back:
        type: sequence
        children: [~reset_children, ~set_var_back]

      ~set_var_back:
        type: action
        script: $reset_var = False

      ~reset_children:
        type: sequence
        children: $_reset_children

      ~seq_w_latches:
        type: t/control_latches_simple
        children: $children
        control_type: $control_type

    unpack:
      children:
        nodes:
          $V_reset_action:
            type: action
            script: __STATE__$V = RUNNING;

    children: $children


  seq_latches:
    args:
      required: [children]
      optional:
        reset_var: ~reset

    nodes:
      $name:
        type: t/control_latches
        children: $children
        reset_var: $reset_var
        control_type: sequence

    children: $children

## planning action definition :)

  planning_action:
    args:
      required: [preconditions, script, postconditions]
    make: action_with_preconditions(preconditions, script, postconditions)
    children: []

  action:
    args:
      required: [script]
      optional:
        preconditions: []
        immediate: null
        postconditions: null
    make: make_action(preconditions, script, immediate, postconditions)
    # note! either immediate or postconditions should be set :)


## actions


  goto:
    args:
      required: [location]

    nodes:
      $name:
        type: t/action
        postconditions:
          - location: $location
            prob: 0.9
          - location: ANY
            prob: 0.1
        script: move_to($location);

    children: []

  put:
    args:
      required: [object, place]

    nodes:
      $name:
        type: t/action
        preconditions:
          - type: t/grasped
            object: $object
          - type: t/close_to_place
            place: $place
        postconditions:
          - grasped: none
            has[$place][$obj]: S
            prob: 0.9
          - grasped: none
            has[ANY][$obj]: S
            prob: 0.09
          - prob: 0.01
        script: put($object, $place);

    children: []

  grasp:
    args:
      required: [object]

    nodes:
      $name:
        type: t/action
        preconditions:
          - type: t/close_to_object
            object: $object
          - type: t/grasped
            object: none
        postconditions:
          - grasped: $object
            prob: 0.9
          - prob: 0.1

    children: []

  detect:
    args:
      required: [object]

    nodes:
      $name:
        type: t/action
        preconditions:
          - type: t/luminousity
        postconditions:
          - seen[$object]: SUCCESS;
            prob: 0.5
          - seen[$object]: FAILURE;
            prob: 0.5
        script: seen[$object] = detect($object);

    children: []

  light_on:
    args:
      required: [location]

    nodes:
      $name:
        type: t/action
        postconditions:
          - can_be_seen[$location]: SUCCESS
            prob: 1
        script: light_on($location)

    children: []

  measure_distance:
    args:
      required: [object]

    nodes:
      $name:
        type: t/action
        preconditions:
          - type: t/seen
            what: $object
        postconditions:
          - close_to_object[$object]: SUCCESS
            prob: 0.5
          - close_to_object[$object]: FAILURE
            prob: 0.5
        script: close_to_object[$object] = measure_reachability($object);

    children: []

## planning condition definition

  planning_condition:
    args:
      required: [on_success]
      optional:
        on_observability: True

    nodes:
      $name:
        type: selector
        children: [~skipper]

      ~skipper:
        type: skipper
        children: [~condition]

      ~condition:
        type: t/condition
        S: $on_observability and $on_success
        F: $on_observability #and not ($on_success)

    children: [~condition, ~skipper, $name]

  planning_condition_var:
    args:
      required: [var]

    nodes:
      $name:
        type: t/planning_condition
        on_success: $var == SUCCESS
        on_observability: $var != RUNNING

    children: []

  planning_condition_var_set:
    args:
      required: [var, value]

    nodes:
      $name:
        type: t/planning_condition
        on_success: $var == $value

  precondition:
    args:
      required: [var]
      optional:
        fail_state: FAILURE
        val: SUCCESS
        obs: null

    make: make_precondition(var, val, fail_state, obs)



## conditions

  grasped:
    args:
      required: [object]

    nodes:
      $name:
        type: t/precondition
        var: grasped
        val: $object


  at:
    args:
      required: [location]

    nodes:
      $name:
        type: t/precondition
        var: location
        val: $location

  close_to_object:
    args:
      required: [object]

    nodes:
      $name:
        type: t/precondition
        var: close_to_object[$object]
        obs:
          type: t/seen
          what: $object

  seen:
    args:
      required: [what]
      optional:
        fail_state: FAILURE

    nodes:
      $name:
        type: t/precondition
        var: seen[$what]
        fail_state: $fail_state
        obs:
          type: t/luminousity
          var: location

  luminousity:
    args:
      required: [location]
      optional:
        fail_state: FAILURE

    nodes:
      $name:
        type: t/precondition
        var: luminousity[$location]
        fail_state: $fail_state

  has:
    args:
      required: [object, place]

    nodes:
      $name:
        type: t/precondition
        var: has[$place][$object]
        obs:
          type: t/seen
          what: $place

  close_to_place:
    args:
      required: [place]

    nodes:
      $name:
        type: t/precondition
        var: closeness[location][$place]




